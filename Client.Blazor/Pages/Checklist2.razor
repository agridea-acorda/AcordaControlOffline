@using Agridea.Acorda.AcordaControlOffline.Client.Blazor.UiServices
@using Agridea.Acorda.AcordaControlOffline.Shared.ApplicationServices.LocalStore
@using Agridea.Acorda.AcordaControlOffline.Shared.Domain.Checklist
@using Microsoft.AspNetCore.Authorization
@using InspectionOutcome = Agridea.Acorda.AcordaControlOffline.Shared.Domain.Inspection.InspectionOutcome
@using Agridea.Acorda.AcordaControlOffline.Client.Blazor.Config
@using Agridea.Acorda.AcordaControlOffline.Shared.ApplicationServices.Api
@using EnsureThat
@inherits PageBase
@page "/Checklist2/{FarmInspectionId:int}"
@attribute [Authorize]
@inject NavigationManager Navigation
@inject IRepository Repository
@inject IToastService Toast
@inject AppConfiguration Config
@inject IJSRuntime Js
@inject IApiClient Api

<div class="card">
    <div class="card-header">
        <h3 class="card-title">Récapitulatif</h3>
        <div class="card-tools">
            <button type="button" class="btn btn-sm btn-default" @onclick='() => Navigation.NavigateTo(Config.BaseUrl + "/MandateDetail/" + farmId)'>
                <i class="fas fa-arrow-left"></i>
                Retour Mandat
            </button>
            <button type="button" class="btn btn-sm btn-success" @onclick='() => Navigation.NavigateTo(Config.BaseUrl + "/Signatures/" + FarmInspectionId + "?FarmId=" + farmId)'>
                <i class="fas fa-arrow-right"></i>
                Rapport pdf et signatures
            </button>
        </div>
    </div>
    <div class="card-body">
        @if (progressBarModel != null)
        {
            <ProgressBar Progress="@progressBarModel" />}
    </div>
</div>

@*<div class="card">
        <div class="card-header">
            <h3 class="card-title">Manquements antérieurs</h3>
            <div class="card-tools">
                <button type="button" class="btn btn-sm btn-default" data-card-widget="collapse">
                    <i class="fas fa-minus"></i>
                </button>
            </div>
        </div>
        <div class="card-body">
            <p>Content here</p>
        </div>
    </div>*@

<div class="card">
    <div class="card-header">
        @if (needsSaving)
        {
            <button class="btn btn-primary float-right" @onclick="@Save" disabled=@saving>
                <i class="@(saving ? "fas fa-spinner fa-spin" : "far fa-save")"></i>
                Enregistrer
            </button>
        }
        <h3 class="card-title">Exigences</h3>
    </div>
    <div class="card-body">
        <p>
            <Blazorise.Switch TValue="bool" @bind-Checked="@showAutoSet"><span class="font-weight-normal">Afficher NA/NC auto</span></Blazorise.Switch>
        </p>
        <div id="checklist">
            <div class="list-group">
                <div id="@(parent?.Id)" class="@(parent != null ? "list-group-item" : null)">
                    @if (parent != null)
                    {
                        <a @onclick="@(() => NodeViewChanged(parent?.ParentConjunctElementCode ?? ""))">
                            <i class="fas fa-chevron-right fa-3x float-left rotate right mr-2"></i>
                        </a>
                        <span class="badge badge-outline text-indigo bg-indigo disabled float-right mr-1">@parent.NumPoints</span>
                        <span class="badge badge-outline text-indigo disabled float-right mr-1">@parent.NumGroups</span>
                        <h4 class="list-group-item-heading">@parent.ShortName</h4>
                        <p class="list-group-item-text mb-2">@parent.ConjunctElementCode</p>
                    }
                    <div class="@(parent != null ? "mt-2" : null)">
                        <div class="list-group">
                            @if (children.Any())
                            {
                                @foreach (var child in children.OrderBy(x => x.Sort).ThenBy(x => x.ConjunctElementCode))
                                {
                                    <ChecklistItem Node="@child"
                                                   ShowIfAutoSet="@showAutoSet"
                                                   OnNodeViewChanged="@NodeViewChanged"
                                                   OnOutcomeChanged="@NodeOutcomeChanged"
                                                   OnEditing="@NodeEditing"
                                                   OnDeleting="@NodeDeleting"
                                                   OnDisplayingInfo="@NodeDisplayingInfo">
                                    </ChecklistItem>
                                }
                            }
                            else
                            {
                                <ChecklistPlaceholderLoading />
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<Blazorise.Modal @ref="@info">
    <Blazorise.ModalBackdrop />
    <Blazorise.ModalContent>
        <Blazorise.ModalHeader>
            <Blazorise.ModalTitle>Aide au contrôle, point @conjunctElementCodeForInfo</Blazorise.ModalTitle>
            <Blazorise.CloseButton Clicked="@HideInfo" />
        </Blazorise.ModalHeader>
        <Blazorise.ModalBody>
            <Blazorise.Field>
                <Blazorise.FieldLabel>@infoText</Blazorise.FieldLabel>
            </Blazorise.Field>
        </Blazorise.ModalBody>
        <Blazorise.ModalFooter>
            <button class="btn btn-default" @onclick="HideInfo">Fermer</button>
        </Blazorise.ModalFooter>
    </Blazorise.ModalContent>
</Blazorise.Modal>

<Blazorise.Modal @ref="@confirmDelete">
    <Blazorise.ModalBackdrop />
    <Blazorise.ModalContent>
        <Blazorise.ModalHeader>
            <Blazorise.ModalTitle>Confirmation</Blazorise.ModalTitle>
            <Blazorise.CloseButton Clicked="@CancelDeleteNode" />
        </Blazorise.ModalHeader>
        <Blazorise.ModalBody>
            <Blazorise.Field>
                <Blazorise.FieldLabel>Êtes-vous sûr de vouloir supprimer les information saisies (résultat, remarques, pièces jointes, ...) ?</Blazorise.FieldLabel>
            </Blazorise.Field>
        </Blazorise.ModalBody>
        <Blazorise.ModalFooter>
            <button class="btn btn-info" @onclick="@DeleteNode">Ok</button>
            <button class="btn btn-default" @onclick="@CancelDeleteNode">Annuler</button>
        </Blazorise.ModalFooter>
    </Blazorise.ModalContent>
</Blazorise.Modal>

<Blazorise.Modal @ref="@edit">
    <Blazorise.ModalBackdrop />
    <EditForm Model="@editModel" OnSubmit="@NodeEdited">
        <Blazorise.ModalContent>
            <Blazorise.ModalHeader>
                <Blazorise.ModalTitle>Résultat détaillé</Blazorise.ModalTitle>
                <Blazorise.CloseButton Clicked="() => edit.Hide()" />
            </Blazorise.ModalHeader>
            <Blazorise.ModalBody>
                <Blazorise.Field>
                    <Blazorise.FieldLabel>Remarque contrôleur</Blazorise.FieldLabel>
                    <Blazorise.MemoEdit Rows="2" @bind-Text="@editModel.InspectorComment"></Blazorise.MemoEdit>
                </Blazorise.Field>
                <Blazorise.Field>
                    <Blazorise.FieldLabel>Remarque exploitant</Blazorise.FieldLabel>
                    <Blazorise.MemoEdit Rows="2" @bind-Text="@editModel.FarmerComment"></Blazorise.MemoEdit>
                </Blazorise.Field>
                <div hidden="@(editModel.HasChildren || editModel.Outcome == InspectionOutcome.Ok)">
                    <Validations @ref="validations" Mode="ValidationMode.Auto">
                        <Blazorise.Validation Validator="@ValidateDefectDescription">
                            @if (editModel.ComboDefects.Any())
                            {
                                <Blazorise.Field>
                                    <Blazorise.FieldLabel>Manquement dans la liste</Blazorise.FieldLabel>
                                    <Blazorise.Select TValue="int?" @bind-SelectedValue="@editModel.DefectId">
                                        @foreach (var option in editModel.ComboDefects)
                                        {
                                            <Blazorise.SelectItem Value="@option.Value">@option.Text</Blazorise.SelectItem>
                                        }
                                    </Blazorise.Select>
                                </Blazorise.Field>
                            }
                            @if (editModel.ComboDefects.Any())
                            {
                                <Blazorise.FieldLabel>OU Manquement constaté</Blazorise.FieldLabel>
                            }
                            else
                            {
                                <Blazorise.FieldLabel>Manquement constaté</Blazorise.FieldLabel>
                            }
                            <Blazorise.TextEdit @bind-Text="@editModel.DefectDescription">
                                <Feedback>
                                    <Blazorise.ValidationError>Le manquement constaté doit soit être choisi dans la liste soit décrit dans le champ textuel (choix exclusif).</Blazorise.ValidationError>
                                </Feedback>
                            </Blazorise.TextEdit>
                        </Blazorise.Validation>
                    </Validations>
                    <Blazorise.Field>
                        <Blazorise.FieldLabel>Ampleur du manquement (par ex: surface, longueur, nombre d'animaux, ...)</Blazorise.FieldLabel>
                        <Blazorise.NumericEdit TValue="double" @bind-Value="@editModel.DefectSize"></Blazorise.NumericEdit>
                    </Blazorise.Field>
                    <div hidden>
                        <Blazorise.Field>
                            <Blazorise.FieldLabel>Unité</Blazorise.FieldLabel>
                            <Blazorise.TextEdit @bind-Text="@editModel.DefectUnit"></Blazorise.TextEdit>
                        </Blazorise.Field>
                    </div>
                    <Blazorise.Field>
                        <Blazorise.FieldLabel>Unité</Blazorise.FieldLabel>
                        <Blazorise.TextEdit @bind-Text="@editModel.Unit" list="units" autocomplete="off" FocusIn='() => { editModel.Unit = ""; }'></Blazorise.TextEdit>
                        <datalist id="units">
                            @foreach (var option in sortListItemsDatasource)
                            {
                                <option>@option.Id</option>
                            }
                        </datalist>
                    </Blazorise.Field>
                    <Blazorise.Field>
                        <Blazorise.FieldLabel>Gravité (uniquement pour l'OPAn et PPr animale)</Blazorise.FieldLabel>
                        <Blazorise.Select TValue="int" @bind-SelectedValue="@editModel.SeriousnessCode">
                            @foreach (var option in editModel.ComboSeriousnesses)
                            {
                                <Blazorise.SelectItem Value="@option.Value">@option.Text</Blazorise.SelectItem>
                            }
                        </Blazorise.Select>
                    </Blazorise.Field>
                </div>
            </Blazorise.ModalBody>
            <Blazorise.ModalFooter>
                <button class="btn btn-primary float-left mr-2" @onclick="@EditOk">Ok</button>
                <button class="btn btn-default float-left mr-2" @onclick="@EditCancelled">Annuler</button>
            </Blazorise.ModalFooter>
        </Blazorise.ModalContent>
    </EditForm>
</Blazorise.Modal>

@code
{
    [Parameter] public int FarmInspectionId { get; set; }
    const string FarmIdUriKey = "FarmId";
    int farmId;
    Checklist checklist;
    ChecklistItem.ResultModel parent;
    List<ChecklistItem.ResultModel> children = new();
    readonly Dictionary<string, (ChecklistItem.ResultModel, List<ChecklistItem.ResultModel>)> viewCache = new();
    AcordaControlOffline.Shared.ApplicationServices.ViewModel.MandateList.InspectionInfo progressBarModel;
    bool saving;
    bool needsSaving;
    bool showAutoSet;
    Blazorise.Modal confirmDelete;
    Blazorise.Modal info;
    Blazorise.Modal edit;
    string conjunctElementCodeToDelete;
    string conjunctElementCodeForInfo;
    string conjunectElementCodeToEdit;
    MarkupString infoText;
    ChecklistItem.ResultModel editModel;

    protected override async Task OnInitializedAsync()
    {
        farmId = int.Parse(Navigation.QueryString(FarmIdUriKey));
        DateTime started = DateTime.Now;
        Console.WriteLine($"Reading checklist data (started {started.ToDetailedTime()})...");
        await Task.Delay(1);
        checklist = await Repository.ReadChecklistAsync(FarmInspectionId);
        TimeSpan elapsed = DateTime.Now - started;
        Console.WriteLine($"Checklist data read succesfully (elapsed {elapsed}).");
        parent = null;
        if (checklist != null)
        {
            children = checklist.Rubrics.Select(r => ChecklistItem.ResultModel.MapFrom(r.Value))
                                .Where(x => x != null)
                                .ToList();
            progressBarModel = AcordaControlOffline.Shared.ApplicationServices.ViewModel.MandateList.InspectionInfo.FromChecklist(checklist);
            viewCache.Add("", (parent, children));
        }
    }

    async Task NodeViewChanged(string conjunctElementCode)
    {
        if (string.IsNullOrWhiteSpace(conjunctElementCode))
        {
            //parent = null;
            //children = checklist.Rubrics.Select(r => ChecklistItem.ResultModel.MapFrom(r.Value))
            //                    .Where(x => x != null)
            //                    .ToList();
            await Task.Delay(1);
            var parentOutcomeResult = GetParentOutcomeBasedOnChildren(children);
            //Console.WriteLine($"parentOutcomeResult :" + JsonSerializer.Serialize(parentOutcomeResult, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));

            parent = viewCache[""].Item1;
            children = viewCache[""].Item2;

            children.Where(x => x.ConjunctElementCode == parentOutcomeResult.ParentConjunctElementCode).Single().Outcome = parentOutcomeResult.ParentOutcome;

            //Console.WriteLine($"parent :" + JsonSerializer.Serialize(parent, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));
            //Console.WriteLine($"children :" + JsonSerializer.Serialize(children, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));

            Console.WriteLine($"conjunctElementCode is null or space");
            return;
        }

        Console.WriteLine($"Finding node with conjunctElementCode={conjunctElementCode}");
        var node = checklist.Find(conjunctElementCode);
        if (node == null)
        {
            //parent = null;
            //children = checklist.Rubrics.Select(r => ChecklistItem.ResultModel.MapFrom(r.Value))
            //                    .Where(x => x != null)
            //                    .ToList();

            parent = viewCache[""].Item1;
            children = viewCache[""].Item2;
            Console.WriteLine($"node is null");
            return;
        }

        if (viewCache.TryGetValue(node.ConjunctElementCode, out var entry))
        {
            await Task.Delay(1);
            var parentOutcomeResult = GetParentOutcomeBasedOnChildren(children);

            parent = entry.Item1;
            children = entry.Item2;

            var temp = children.SingleOrDefault(x => x.ConjunctElementCode == parentOutcomeResult.ParentConjunctElementCode);
            if (temp != null)
            {
                temp.Outcome = parentOutcomeResult.ParentOutcome;
            }
            Console.WriteLine($"from view cache");
            return;
        }
        parent = ChecklistItem.ResultModel.MapFrom(node);
        children = node.Children.Select(x => ChecklistItem.ResultModel.MapFrom(x.Value))
                       .Where(x => x != null)
                       .ToList();
        viewCache.TryAdd(node.ConjunctElementCode, (parent, children));

    }

    async Task NodeOutcomeChanged(ChecklistItem.ResultModel model)
    {
        Console.WriteLine($"Node {model.ConjunctElementCode}'s outcome was set to {model.Outcome}.");
        var node = checklist.Find(model.ConjunctElementCode);
        var previousOutcome = node.Outcome;
        node.SetOutcome(model.Outcome);
        if (previousOutcome != model.Outcome) node.SetAuto(false);
        await Task.Delay(1);
        GetParentOutcomeBasedOnChildren(children);
        await CheckRulesFromParentToChildren(model.ConjunctElementCode, model.Outcome);
        progressBarModel.SetOutcome(checklist.OutcomeComputed);
        progressBarModel.Progress(checklist.Percent);
        needsSaving = true;
    }

    void NodeEditing(string conjunctElementCode)
    {
        conjunectElementCodeToEdit = conjunctElementCode;
        var model = children.SingleOrDefault(x => x.ConjunctElementCode == conjunctElementCodeToDelete);
        Ensure.That(model, nameof(model)).IsNotNull();
        editModel = model;
    }

    void NodeEdited()
    {
        Console.WriteLine($"Node {editModel.ConjunctElementCode} was edited.");

        checklist.Find(editModel.ConjunctElementCode)
            .SetInspectorComment(editModel.InspectorComment)
            .SetFarmerComment(editModel.FarmerComment)
            .SetDefect(new Defect(editModel.DefectDescription, new Defect.Measurement(editModel.DefectSize, editModel.DefectUnit)), DefectSeriousness.FromCode(editModel.SeriousnessCode))
            .SetDefectId(editModel.DefectId)
            .SetUnit(editModel.Unit)
            .SetAuto(false);
        
        needsSaving = true;
    }

    void EditOk(){}

    void EditCancelled()
    {
    }

    void NodeDeleting(string conjunctElementCode)
    {
        conjunctElementCodeToDelete = conjunctElementCode;
        confirmDelete.Show();
    }

    async Task DeleteNode()
    {
        Console.WriteLine($"Deleting result for node {conjunctElementCodeToDelete}...");
        confirmDelete.Hide();

        var model = children.SingleOrDefault(x => x.ConjunctElementCode == conjunctElementCodeToDelete);
        Ensure.That(model, nameof(model)).IsNotNull();

        model.Clear();
        await Task.Delay(1);

        checklist.Find(model.ConjunctElementCode)
            .SetOutcome(InspectionOutcome.Unset)
            .SetInspectorComment("")
            .SetFarmerComment("")
            .SetDefect(Defect.None, DefectSeriousness.Empty)
            .SetDefectId(null)
            .SetAuto(false);

        await Task.Delay(1);
        GetParentOutcomeBasedOnChildren(children);

        progressBarModel.Progress(checklist.Percent);
        progressBarModel.SetOutcome(checklist.OutcomeComputed);
        needsSaving = true;
        conjunctElementCodeToDelete = "";
        Console.WriteLine($"Result deleted for node {model.ConjunctElementCode}.");
    }

    void CancelDeleteNode()
    {
        conjunctElementCodeToDelete = "";
        confirmDelete.Hide();
    }

    void NodeDisplayingInfo(string conjunctElementCode)
    {
        var model = children.SingleOrDefault(x => x.ConjunctElementCode == conjunctElementCode);
        Ensure.That(model, nameof(model)).IsNotNull();
        infoText = (MarkupString)model.Name?.CurateAsReadableText();
        conjunctElementCodeForInfo = conjunctElementCode;
        info.Show();
    }

    void HideInfo()
    {
        infoText = default;
        conjunctElementCodeForInfo = default;
        info.Hide();
    }

    async Task Save()
    {
        if (saving || !needsSaving) return;
        saving = true;
        await Task.Delay(1);
        StateHasChanged();
        GetParentOutcomeBasedOnChildren(children);
        try
        {
            Console.WriteLine("Saving checklist...");
            await Js.InvokeVoidAsync("console.time", "Checklist2.Save");

            await Repository.SaveChecklistAsync(checklist);

            // below should be performed with domain event dispatching mechanism
            var checklistEvent = new NodeOutcomeChanged(checklist.OutcomeComputed, checklist.Percent, FarmInspectionId);
            await UpdateAndSaveInspectionPercentAndOutcome(Repository, farmId, checklistEvent);
            await UpdateAndSaveInspectionInfoPercentAndOutcome(Repository, farmId, checklistEvent);
            Console.WriteLine("...checklist saved.");
            Toast.Success();
        }
        finally
        {
            saving = false;
            needsSaving = false;
            await Js.InvokeVoidAsync("console.timeEnd", "Checklist2.Save");
            StateHasChanged();
        }
    }

    private async Task UpdateAndSaveInspectionPercentAndOutcome(IRepository repository, int farmId, NodeOutcomeChanged e)
    {
        var mandate = await repository.ReadMandateAsync(farmId);
        if (mandate == null)
        {
            string error = $"Mandat introuvable (FarmId={farmId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }

        var inspection = mandate.Inspections.FirstOrDefault(x => x.FarmInspectionId == e.FarmInspectionId);
        if (inspection == null)
        {
            string error = $"Contrôle introuvable (FarmInspectionId={e.FarmInspectionId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }
        inspection.Progress(e.Percent * 100);
        inspection.SetOutcome(e.Outcome);
        await repository.SaveMandateAsync(mandate, farmId);
    }

    private async Task UpdateAndSaveInspectionInfoPercentAndOutcome(IRepository repository, int farmId, NodeOutcomeChanged e)
    {
        var mandates = await repository.ReadAllMandatesAsync();
        var mandate = mandates.FirstOrDefault(x => x.Farm.Id == farmId);
        if (mandate == null)
        {
            string error = $"Mandat introuvable (FarmId={farmId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }

        var inspectionInfo = mandate.Inspections.FirstOrDefault(x => x.FarmInspectionId == e.FarmInspectionId);
        if (inspectionInfo == null)
        {
            string error = $"Contrôle introuvable (FarmInspectionId={e.FarmInspectionId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }

        inspectionInfo.SetOutcome(e.Outcome);
        inspectionInfo.Progress(e.Percent);
        await repository.SaveMandatesAsync(mandates);
    }

    /// <summary>Checks if InspectionOutcome of parent is correct (Could be incorrect if children's InspectionOutcome have a value)</summary>
    /// <param name="conjunctElementCode">The code of the id of the node of a InspectionOutcome</param>
    /// <param name="check">The InspectionOutcome to check</param>
    async Task CheckRulesFromParentToChildren(string conjunctElementCode, InspectionOutcome check)
    {
        var node = checklist.Find(conjunctElementCode);
        var tempChildren = new List<ChecklistItem.ResultModel>();
        if (viewCache.TryGetValue(conjunctElementCode, out var entry))
        {
            await Task.Delay(1);
            tempChildren = entry.Item2;
        }
        else
        {
            tempChildren = node.Children.Select(x => ChecklistItem.ResultModel.MapFrom(x.Value))
            .Where(x => x != null)
            .ToList();
        }

        var temp = tempChildren.Where(x => x.ParentConjunctElementCode == conjunctElementCode).ToList();
        int cptNOk = 0;
        int cptPOk = 0;
        int cptOk = 0;
        int cptNa = 0;
        int cptNc = 0;

        //Console.WriteLine($"check child count :" + temp.Count);
        foreach (var child in temp)
        {
            //Console.WriteLine($"check child :" + child.Outcome.Code);

            switch (child.Outcome.Code)
            {
                case "NOk":
                    cptNOk++;
                    break;
                case "PartiallyOk":
                    cptPOk++;
                    break;
                case "Ok":
                    cptOk++;
                    break;
                case "NotApplicable":
                    cptNa++;
                    break;
                case "NotInspected":
                    cptNc++;
                    break;
            }
        }

        //Console.WriteLine(check.Code);
        //Console.WriteLine(cptNOk);
        //Console.WriteLine(cptPOk);
        //Console.WriteLine(cptOk);
        //Console.WriteLine(cptNa);
        //Console.WriteLine(cptNc);
        if (cptNOk > 0 && check == InspectionOutcome.NotOk)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (NOk)");
        }
        else if (cptPOk > 0 && check == InspectionOutcome.PartiallyOk && cptNOk == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (POk)");
        }
        else if (cptOk > 0 && check == InspectionOutcome.Ok && cptNOk == 0 && cptPOk == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (Ok)");
        }
        else if (cptNa > 0 && check == InspectionOutcome.NotApplicable && cptNOk == 0 && cptPOk == 0 && cptOk == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (Na)");
        }
        else if (cptNc > 0 && check == InspectionOutcome.NotInspected && cptNOk == 0 && cptPOk == 0 && cptOk == 0 && cptNa == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (Nc)");
        }
        else if (cptNOk == 0 && cptPOk == 0 && cptOk == 0 && cptNa == 0 && cptNc == 0)
        {

        }
        else
        {
            Toast.ShowWarning($"Le point de contrôle est incohérent ({check.Code}), vérifiez le sous-groupe", "ATTENTION");
        }
    }

    /// <summary>Calculates and sets the InspectionOutcome's value of the parents nodes based on children</summary>
    /// <param name="childNodes">The children, needed to calculate the outcome</param>
    ParentOutcomeResult GetParentOutcomeBasedOnChildren(List<ChecklistItem.ResultModel> childNodes)
    {
        //Console.WriteLine($"children :" + JsonSerializer.Serialize(children, new JsonSerializerOptions(){ReferenceHandler = ReferenceHandler.Preserve }));
        ParentOutcomeResult parentOutcomeResult = new ParentOutcomeResult();

        if (childNodes != null)
        {

            parentOutcomeResult.ParentConjunctElementCode = childNodes.FirstOrDefault()?.ParentConjunctElementCode;

            int cptNOk = 0;
            int cptPOk = 0;
            int cptOk = 0;
            int cptNa = 0;
            int cptNc = 0;
            //Console.WriteLine($"children :" + children.Count);
            foreach (var child in childNodes)
            {
                //Console.WriteLine($"child :" + child.Outcome.Code);

                switch (child.Outcome.Code)
                {
                    case "NOk":
                        cptNOk++;
                        break;
                    case "PartiallyOk":
                        cptPOk++;
                        break;
                    case "Ok":
                        cptOk++;
                        break;
                    case "NotApplicable":
                        cptNa++;
                        break;
                    case "NotInspected":
                        cptNc++;
                        break;
                }
            }


            if (cptNOk > 0)
            {
                //Console.WriteLine($"outcomeParent SHOULD BE NOK");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.NotOk;
            }
            else if (cptPOk > 0)
            {
                //Console.WriteLine($"outcomeParent SHOULD BE POK");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.PartiallyOk;
            }
            else if (cptOk > 0)
            {
                //Console.WriteLine($"outcomeParent SHOULD BE OK");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.Ok;
            }
            else if (cptNa > 0)
            {
                //Console.WriteLine($"outcomeParent SHOULD BE NA");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.NotApplicable;
            }
            else if (cptNc > 0)
            {
                //Console.WriteLine($"outcomeParent SHOULD BE NC");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.NotInspected;
            }
            else
            {
                //Console.WriteLine($"outcomeParent SHOULD BE NOTHING");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.Unset;
            }
        }

        string parentConjunctElementCode = parent?.ConjunctElementCode;
        if (parentConjunctElementCode != null)
        {
            //Console.WriteLine($"parentConjunctElementCode :" + JsonSerializer.Serialize(parentConjunctElementCode, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));
            var node = checklist.Find(parentConjunctElementCode);
            //Console.WriteLine(JsonSerializer.Serialize(node, new JsonSerializerOptions(){ReferenceHandler = ReferenceHandler.Preserve}));
            var previousOutcome = node.Outcome;
            node.SetOutcome(parentOutcomeResult.ParentOutcome);
            parent.Outcome = parentOutcomeResult.ParentOutcome;
            if (previousOutcome != parentOutcomeResult.ParentOutcome) node.SetAuto(false);
        }

        progressBarModel.SetOutcome(checklist.OutcomeComputed);
        progressBarModel.Progress(checklist.Percent);

        return parentOutcomeResult;
    }

    private class ParentOutcomeResult
    {
        public string ParentConjunctElementCode { get; set; }
        public InspectionOutcome ParentOutcome { get; set; }
    }

    public class InfoModel
    {
        public string ConjunctElementCode { get; set; }
        public string InfoText { get; set; }
    }
}