@using Agridea.Acorda.AcordaControlOffline.Client.Blazor.UiServices
@using Agridea.Acorda.AcordaControlOffline.Shared.ApplicationServices.LocalStore
@using Agridea.Acorda.AcordaControlOffline.Shared.Domain.Checklist
@using Ardalis.GuardClauses
@using Microsoft.AspNetCore.Authorization
@using InspectionOutcome = Agridea.Acorda.AcordaControlOffline.Shared.Domain.Inspection.InspectionOutcome
@using Agridea.Acorda.AcordaControlOffline.Client.Blazor.Config
@using System.Text.Json
@using System.Text.Json.Serialization
@inherits PageBase
@page "/Checklist2/{FarmInspectionId:int}"
@attribute [Authorize]
@inject NavigationManager Navigation
@inject IRepository Repository
@inject IToastService Toast
@inject AppConfiguration Config
@inject IJSRuntime Js

<div class="card">
    <div class="card-header">
        <h3 class="card-title">Récapitulatif</h3>
        <div class="card-tools">
            <button type="button" class="btn btn-sm btn-default" @onclick='() => Navigation.NavigateTo(Config.BaseUrl + "/MandateDetail/" + farmId)'>
                <i class="fas fa-arrow-left"></i>
                Retour Mandat
            </button>
            <button type="button" class="btn btn-sm btn-success" @onclick='() => Navigation.NavigateTo(Config.BaseUrl + "/Signatures/" + FarmInspectionId + "?FarmId=" + farmId)'>
                <i class="fas fa-arrow-right"></i>
                Rapport pdf et signatures
            </button>
        </div>
    </div>
    <div class="card-body">
        @if (progressBarModel != null)
        {
<ProgressBar Progress="@progressBarModel" />}
    </div>
</div>

@*<div class="card">
        <div class="card-header">
            <h3 class="card-title">Manquements antérieurs</h3>
            <div class="card-tools">
                <button type="button" class="btn btn-sm btn-default" data-card-widget="collapse">
                    <i class="fas fa-minus"></i>
                </button>
            </div>
        </div>
        <div class="card-body">
            <p>Content here</p>
        </div>
    </div>*@

<div class="card">
    <div class="card-header">
        @if (needsSaving)
        {
<button class="btn btn-primary float-right" @onclick="@Save" disabled=@saving>
    <i class="@(saving ? "fas fa-spinner fa-spin" : "far fa-save")"></i>
    Enregistrer
</button>}
        <h3 class="card-title">Exigences</h3>
    </div>
    <div class="card-body">
        <p>
            <Blazorise.Switch TValue="bool" @bind-Checked="@showAutoSet"><span class="font-weight-normal">Afficher NA/NC auto</span></Blazorise.Switch>
        </p>
        <div id="checklist">
            <div class="list-group">
                @if (parent != null)
                {
    <div id="@parent.Id" class="list-group-item">
        <a @onclick="@(() => NodeViewChanged(parent?.ParentConjunctElementCode ?? ""))">
            <i class="fas fa-chevron-right fa-3x float-left rotate right mr-2"></i>
        </a>
        <span class="badge badge-outline text-indigo bg-indigo disabled float-right mr-1">@parent.NumPoints</span>
        <span class="badge badge-outline text-indigo disabled float-right mr-1">@parent.NumGroups</span>
        <h4 class="list-group-item-heading">@parent.ShortName</h4>
        <p class="list-group-item-text mb-2">@parent.ConjunctElementCode</p>
        <div class="mt-2">
            <div class="list-group">
                @if (children.Any())
                {
@foreach (var child in children)
{
<ChecklistItem Node="@child" ShowIfAutoSet="@showAutoSet" OnNodeViewChanged="@NodeViewChanged" OnOutcomeChanged="@NodeOutcomeChanged" OnNodeEdited="@NodeEdited" OnDeleted="@NodeDeleted"></ChecklistItem>} }
else
{
<ChecklistPlaceholderLoading />}
            </div>
        </div>
    </div> }
else
{
@if (children.Any())
{
@foreach (var child in children)
{
<ChecklistItem Node="@child" ShowIfAutoSet="@showAutoSet" OnNodeViewChanged="@NodeViewChanged" OnOutcomeChanged="@NodeOutcomeChanged" OnNodeEdited="@NodeEdited" OnDeleted="@NodeDeleted"></ChecklistItem>} }
else
{
<ChecklistPlaceholderLoading />}}
            </div>
        </div>
    </div>
</div>

@code { const string FarmIdUriKey = "FarmId";

    [Parameter]
    public int FarmInspectionId { get; set; }

    int farmId;
    Checklist checklist;
    ChecklistItem.ResultModel parent;
    List<ChecklistItem.ResultModel> children = new List<ChecklistItem.ResultModel>();
    Dictionary<string, (ChecklistItem.ResultModel, List<ChecklistItem.ResultModel>)> viewCache = new Dictionary<string, (ChecklistItem.ResultModel, List<ChecklistItem.ResultModel>)>();
    AcordaControlOffline.Shared.ApplicationServices.ViewModel.MandateList.InspectionInfo progressBarModel;
    bool saving;
    bool needsSaving;
    bool showAutoSet = false;

    protected override async Task OnInitializedAsync()
    {
        farmId = int.Parse(Navigation.QueryString(FarmIdUriKey));
        DateTime started = DateTime.Now;
        Console.WriteLine($"Reading checklist data (started {started.ToDetailedTime()})...");
        await Task.Delay(1); // workaround (otherwise ui is not rendered until repository has finished loading)
        checklist = await Repository.ReadChecklistAsync(FarmInspectionId);
        TimeSpan elapsed = DateTime.Now - started;
        Console.WriteLine($"Checklist data read succesfully (elapsed {elapsed}).");
        parent = null;
        if (checklist != null)
        {
            children = checklist.Rubrics.Select(r => ChecklistItem.ResultModel.MapFrom(r.Value))
                                .Where(x => x != null)
                                .ToList();
            progressBarModel = AcordaControlOffline.Shared.ApplicationServices.ViewModel.MandateList.InspectionInfo.FromChecklist(checklist);
            viewCache.Add("", (parent, children));
        }
    }

    async Task NodeViewChanged(string conjunctElementCode)
    {
        if (string.IsNullOrWhiteSpace(conjunctElementCode))
        {
            //parent = null;
            //children = checklist.Rubrics.Select(r => ChecklistItem.ResultModel.MapFrom(r.Value))
            //                    .Where(x => x != null)
            //                    .ToList();
            await Task.Delay(1);
            var parentOutcomeResult = await GetParentOutcomeBasedOnChildren(children);
            //Console.WriteLine($"parentOutcomeResult :" + JsonSerializer.Serialize(parentOutcomeResult, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));

            parent = viewCache[""].Item1;
            children = viewCache[""].Item2;

            children.Where(x => x.ConjunctElementCode == parentOutcomeResult.ParentConjunctElementCode).Single().Outcome = parentOutcomeResult.ParentOutcome;

            //Console.WriteLine($"parent :" + JsonSerializer.Serialize(parent, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));
            //Console.WriteLine($"children :" + JsonSerializer.Serialize(children, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));

            Console.WriteLine($"conjunctElementCode is null or space");
            return;
        }

        Console.WriteLine($"Finding node with conjunctElementCode={conjunctElementCode}");
        var node = checklist.Find(conjunctElementCode);
        if (node == null)
        {
            //parent = null;
            //children = checklist.Rubrics.Select(r => ChecklistItem.ResultModel.MapFrom(r.Value))
            //                    .Where(x => x != null)
            //                    .ToList();

            parent = viewCache[""].Item1;
            children = viewCache[""].Item2;
            Console.WriteLine($"node is null");
            return;
        }

        if (viewCache.TryGetValue(node.ConjunctElementCode, out var entry))
        {
            await Task.Delay(1);
            var parentOutcomeResult = await GetParentOutcomeBasedOnChildren(children);

            parent = entry.Item1;
            children = entry.Item2;

            var temp = children.Where(x => x.ConjunctElementCode == parentOutcomeResult.ParentConjunctElementCode).SingleOrDefault();
            if (temp != null)
            {
                temp.Outcome = parentOutcomeResult.ParentOutcome;
            }
            Console.WriteLine($"from view cache");
            return;
        }
        parent = ChecklistItem.ResultModel.MapFrom(node);
        children = node.Children.Select(x => ChecklistItem.ResultModel.MapFrom(x.Value))
                       .Where(x => x != null)
                       .ToList();
        viewCache.TryAdd(node.ConjunctElementCode, (parent, children));
    }

    async Task NodeOutcomeChanged(ChecklistItem.ResultModel model)
    {
        Console.WriteLine($"Node {model.ConjunctElementCode}'s outcome was set to {model.Outcome}.");
        var node = checklist.Find(model.ConjunctElementCode);
        var previousOutcome = node.Outcome;
        node.SetOutcome(model.Outcome);
        if (previousOutcome != model.Outcome) node.SetAuto(false);
        await Task.Delay(1);
        await GetParentOutcomeBasedOnChildren(children);
        await CheckRulesFromParentToChildren(model.ConjunctElementCode, model.Outcome);
        progressBarModel.SetOutcome(checklist.OutcomeComputed);
        progressBarModel.Progress(checklist.Percent);
        needsSaving = true;
    }

    void NodeEdited(ChecklistItem.ResultModel model)
    {
        Console.WriteLine($"Node {model.ConjunctElementCode} was edited.");
        checklist.Find(model.ConjunctElementCode)
                 .SetInspectorComment(model.InspectorComment)
                 .SetFarmerComment(model.FarmerComment)
                 .SetDefect(new Defect(model.DefectDescription, new Defect.Measurement(model.DefectSize, model.DefectUnit)),
                            DefectSeriousness.FromCode(model.SeriousnessCode))
                 .SetAuto(false);
        needsSaving = true;
    }

    async Task NodeDeleted(ChecklistItem.ResultModel model)
    {
        Console.WriteLine($"Node {model.ConjunctElementCode}'s info was deleted.");
        checklist.Find(model.ConjunctElementCode)
                 .SetOutcome(InspectionOutcome.Unset)
                 .SetInspectorComment("")
                 .SetFarmerComment("")
                 .SetDefect(Defect.None, DefectSeriousness.Empty)
                 .SetAuto(false);

        await Task.Delay(1);
        await GetParentOutcomeBasedOnChildren(children);

        progressBarModel.Progress(checklist.Percent);
        progressBarModel.SetOutcome(checklist.OutcomeComputed);
        needsSaving = true;
    }

    async Task Save()
    {
        if (saving || !needsSaving) return;
        saving = true;
        await Task.Delay(1);
        StateHasChanged();

        try
        {
            Console.WriteLine("Saving checklist...");
            await Js.InvokeVoidAsync("console.time", "Checklist2.Save");
            await Repository.SaveChecklistAsync(checklist);

            // below should be performed with domain event dispatching mechanism
            var checklistEvent = new NodeOutcomeChanged(checklist.OutcomeComputed, checklist.Percent, FarmInspectionId);
            await UpdateAndSaveInspectionPercentAndOutcome(Repository, farmId, checklistEvent);
            await UpdateAndSaveInspectionInfoPercentAndOutcome(Repository, farmId, checklistEvent);
            Console.WriteLine("...checklist saved.");
            Toast.Success();
        }
        finally
        {
            saving = false;
            needsSaving = false;
            await Js.InvokeVoidAsync("console.timeEnd", "Checklist2.Save");
            StateHasChanged();
        }
    }

    private async Task UpdateAndSaveInspectionPercentAndOutcome(IRepository repository, int farmId, NodeOutcomeChanged e)
    {
        var mandate = await repository.ReadMandateAsync(farmId);
        if (mandate == null)
        {
            string error = $"Mandat introuvable (FarmId={farmId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }

        var inspection = mandate.Inspections.FirstOrDefault(x => x.FarmInspectionId == e.FarmInspectionId);
        if (inspection == null)
        {
            string error = $"Contrôle introuvable (FarmInspectionId={e.FarmInspectionId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }
        inspection.Progress(e.Percent * 100);
        inspection.SetOutcome(e.Outcome);
        await repository.SaveMandateAsync(mandate, farmId);
    }

    private async Task UpdateAndSaveInspectionInfoPercentAndOutcome(IRepository repository, int farmId, NodeOutcomeChanged e)
    {
        var mandates = await repository.ReadAllMandatesAsync();
        var mandate = mandates.FirstOrDefault(x => x.Farm.Id == farmId);
        if (mandate == null)
        {
            string error = $"Mandat introuvable (FarmId={farmId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }

        var inspectionInfo = mandate.Inspections.FirstOrDefault(x => x.FarmInspectionId == e.FarmInspectionId);
        if (inspectionInfo == null)
        {
            string error = $"Contrôle introuvable (FarmInspectionId={e.FarmInspectionId})";
            Console.WriteLine(error);
            Toast.Error(error);
            return;
        }

        inspectionInfo.SetOutcome(e.Outcome);
        inspectionInfo.Progress(e.Percent);
        await repository.SaveMandatesAsync(mandates);
    }

    private class ParentOutcomeResult
    {
        public string ParentConjunctElementCode { get; set; }
        public InspectionOutcome ParentOutcome { get; set; }
    }

    /// <summary>Checks if InspectionOutcome of parent is correct (Could be incorrect if children's InspectionOutcome have a value)</summary>
    /// <param name="conjunctElementCode">The code of the id of the node of a InspectionOutcome</param>
    /// <param name="check">The InspectionOutcome to check</param>
    async Task CheckRulesFromParentToChildren(string conjunctElementCode, InspectionOutcome check)
    {
        var node = checklist.Find(conjunctElementCode);
        var tempChildren = new List<ChecklistItem.ResultModel>();
        if (viewCache.TryGetValue(conjunctElementCode, out var entry))
        {
            await Task.Delay(1);
            tempChildren = entry.Item2;
        }
        else
        {
            tempChildren = node.Children.Select(x => ChecklistItem.ResultModel.MapFrom(x.Value))
            .Where(x => x != null)
            .ToList();
        }

        var temp = tempChildren.Where(x => x.ParentConjunctElementCode == conjunctElementCode).ToList();
        int cptNOk = 0;
        int cptPOk = 0;
        int cptOk = 0;
        int cptNa = 0;
        int cptNc = 0;

        Console.WriteLine($"check child count :" + temp.Count);
        foreach (var child in temp)
        {
            Console.WriteLine($"check child :" + child.Outcome.Code);

            switch (child.Outcome.Code)
            {
                case "NOk":
                    cptNOk++;
                    break;
                case "PartiallyOk":
                    cptPOk++;
                    break;
                case "Ok":
                    cptOk++;
                    break;
                case "NotApplicable":
                    cptNa++;
                    break;
                case "NotInspected":
                    cptNc++;
                    break;
            }
        }

        //Console.WriteLine(check.Code);
        //Console.WriteLine(cptNOk);
        //Console.WriteLine(cptPOk);
        //Console.WriteLine(cptOk);
        //Console.WriteLine(cptNa);
        //Console.WriteLine(cptNc);
        if (cptNOk > 0 && check == InspectionOutcome.NotOk)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (NOk)");
        }
        else if (cptPOk > 0 && check == InspectionOutcome.PartiallyOk && cptNOk == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (POk)");
        }
        else if (cptOk > 0 && check == InspectionOutcome.Ok && cptNOk == 0 && cptPOk == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (Ok)");
        }
        else if (cptNa > 0 && check == InspectionOutcome.NotApplicable && cptNOk == 0 && cptPOk == 0 && cptOk == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (Na)");
        }
        else if (cptNc > 0 && check == InspectionOutcome.NotInspected && cptNOk == 0 && cptPOk == 0 && cptOk == 0 && cptNa == 0)
        {
            //Toast.ShowWarning("Le point de contrôle est cohérent (Nc)");
        }
        else if (cptNOk == 0 && cptPOk == 0 && cptOk == 0 && cptNa == 0 && cptNc == 0)
        {

        }
        else
        {
            Toast.ShowWarning($"Le point de contrôle est incohérent ({check.Code}), vérifiez le sous-groupe");
        }
    }

    /// <summary>Calculates and sets the InspectionOutcome's value of the parents nodes based on children</summary>
    /// <param name="children">The children, needed to calculate the outcome</param>
    async Task<ParentOutcomeResult> GetParentOutcomeBasedOnChildren(List<ChecklistItem.ResultModel> children)
    {
        //Console.WriteLine($"children :" + JsonSerializer.Serialize(children, new JsonSerializerOptions(){ReferenceHandler = ReferenceHandler.Preserve }));
        ParentOutcomeResult parentOutcomeResult = new ParentOutcomeResult();

        if (children != null)
        {

            parentOutcomeResult.ParentConjunctElementCode = children.FirstOrDefault()?.ParentConjunctElementCode;

            int cptNOk = 0;
            int cptPOk = 0;
            int cptOk = 0;
            int cptNa = 0;
            int cptNc = 0;
            Console.WriteLine($"children :" + children.Count);
            foreach (var child in children)
            {
                Console.WriteLine($"child :" + child.Outcome.Code);

                switch (child.Outcome.Code)
                {
                    case "NOk":
                        cptNOk++;
                        break;
                    case "PartiallyOk":
                        cptPOk++;
                        break;
                    case "Ok":
                        cptOk++;
                        break;
                    case "NotApplicable":
                        cptNa++;
                        break;
                    case "NotInspected":
                        cptNc++;
                        break;
                }
            }


            if (cptNOk > 0)
            {
                Console.WriteLine($"outcomeParent SHOULD BE NOK");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.NotOk;
            }
            else if (cptPOk > 0)
            {
                Console.WriteLine($"outcomeParent SHOULD BE POK");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.PartiallyOk;
            }
            else if (cptOk > 0)
            {
                Console.WriteLine($"outcomeParent SHOULD BE OK");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.Ok;
            }
            else if (cptNa > 0)
            {
                Console.WriteLine($"outcomeParent SHOULD BE NA");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.NotApplicable;
            }
            else if (cptNc > 0)
            {
                Console.WriteLine($"outcomeParent SHOULD BE NC");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.NotInspected;
            }
            else
            {
                Console.WriteLine($"outcomeParent SHOULD BE NOTHING");
                parentOutcomeResult.ParentOutcome = InspectionOutcome.Unset;
            }
        }

        string parentConjunctElementCode = parent?.ConjunctElementCode;
        if (parentConjunctElementCode != null)
        {
            //Console.WriteLine($"parentConjunctElementCode :" + JsonSerializer.Serialize(parentConjunctElementCode, new JsonSerializerOptions() { ReferenceHandler = ReferenceHandler.Preserve }));
            var node = checklist.Find(parentConjunctElementCode);
            //Console.WriteLine(JsonSerializer.Serialize(node, new JsonSerializerOptions(){ReferenceHandler = ReferenceHandler.Preserve}));
            var previousOutcome = node.Outcome;
            node.SetOutcome(parentOutcomeResult.ParentOutcome);
            parent.Outcome = parentOutcomeResult.ParentOutcome;
            if (previousOutcome != parentOutcomeResult.ParentOutcome) node.SetAuto(false);
        }

        progressBarModel.SetOutcome(checklist.OutcomeComputed);
        progressBarModel.Progress(checklist.Percent);

        return parentOutcomeResult;
    } }